public class _0070_Arrays {

	public static void main(String[] args) {
		// Un array en java es una estructura de datos que nos permite
		//almacenar una colección de datos de un mismo tipo.

		// Podemos entender un array como tener muchas variables
		// de un mismo declaradas en una estructura.
		
		// Ejemplo, si queremos almacenar 5 números en memoria
		// necesitariamos 5 variables de tipo int
		int n1 = 1;
		int n2 = 2;
		int n3 = 3;
		int n4 = 4;
		int n5 = 5;
		
		//Si quisieramos imprimirlo, tendriamos que ir 1 a 1
		System.out.println(n1);
		System.out.println(n2);
		System.out.println(n3);
		System.out.println(n4);
		System.out.println(n5);
		
		// Los arrays nos permiten almacenar un número de variables
		//dentro de una misma "variable"
		
		//Podemos declarar un array de la siguiente manera
		int[] arrayNumeros = new int[5];
		/*
		 * Los corchetes [] después del tipo indican que la variable
		 * es un array.
		 * En la asignación le indicamos con la palabra new que genere
		 * el array vacía.
		 * int[5] --> indica que puede albergar 5 valores diferentes.
		 * El número dentro de los corchetes indica la cantidad de
		 * elementos que puede tener.
		 * 
		 * ATENCION: esto no se puede variar.
		 * 
		 * ==================
		 * =   POSICIONES   =
		 * ==================
		 * 
		 * Empiezan a contar desde 0. En el caso anterior tendremos
		 * posiciones que van de 0 a 4.
		 * 
		 * La variable se llama arrayNumeros, pues la primera posición
		 * es arrayNumeros[0]. Así sucesivamente.
		 */
		
		System.out.println("------------ Arrays -----------------");
		
		// Los arrays enteros por defecto se inicializan todas las posiciones
		// a 0.
		arrayNumeros[0] = 1;
		arrayNumeros[1] = 2;
		arrayNumeros[2] = 3;
		arrayNumeros[3] = 4;
		arrayNumeros[4] = 5;
		
		//Para acceder a una posición del array se hace de la misma manera
		System.out.println(arrayNumeros[0]);//Esta seria la primera posición del array
		System.out.println(arrayNumeros[1]);//Esta sería la segunda posición del array
		System.out.println(arrayNumeros[2]);//Esta sería la tercera posición del array
		System.out.println(arrayNumeros[3]);//Esta sería la cuarta posición del array
		System.out.println(arrayNumeros[4]);//Esta sería la quinta posición del array
											//o la última posición del array
		
		//Ojo, si accedéis o modificais una posición que no existe, da error
		//en tiempo de ejecución, concretamente ArrayIndexOutOfBoundsException
		//arrayNumeros[5] = 6;//No da error en tiempo de compilación, pero si en ejecución
		
		//Una vez creado el array, NO se puede modificar el tamaño. Es por esto que este
		//tipo de array en java se conoce como "array estatico"
		
		//Podemos conocer la longitud de un array gracias a la propiedad "length"
		System.out.println("El tamaño del array es: " + arrayNumeros.length);//5
		
		//Gracias a que un array es una colección de variables se puede recorrer
		//con bucles
		
		//Ejemplo, guardar los primeros 1000 numeros en variables
		int[] arrayMilNumeros = new int[100];
		//arrayMilNumeros[0] = 1;
		//arrayMilNumeros[1] = 2;
		//arrayMilNumeros[2] = 3;
		//Esto es inviable....
		//Hay que usar bucles
		/*
		for(int i = 0; i < 100; i++) {//i <= 99;
			arrayMilNumeros[i] = i + 1;
			System.out.println("Vuelta número: " + (i + 1));
			System.out.println("Asignación a la posición " + i + " del array de 1000 números: " + arrayMilNumeros[i]);
		}
		*/
		//Iteración 1
		//i = 0;
		//arrayMilnumeros[0] = 1
		//Iteración 2
		//i = 1;
		//arrayMilnumeros[1] = 2
		//Iteración 3
		//i = 2;
		//arrayMilnumeros[2] = 3
		//Iteración 4
		//i = 3;
		//arrayMilnumeros[3] = 4
		//....
		/*
		System.out.println("Ahora imprimimos el bucle");
		for(int i = 0; i < 100; i++) {
			System.out.println(arrayMilNumeros[i]);
		}
		*/
		/*
		a) te imprime los numeros del 1 al 1000
		b) te imprime los numeros del 0 al 1000
		c) te imprime los numeros del 0 al 999
		d) error en tiempo de complacion
		e) error en tiempo de ejecución
		*/
		
		//Normalmente para recorrer un array se usa como condición de parada
		//la propiedad "length"
		System.out.println("==================*********=================");
		System.out.println("El arrayMilNumeros tiene una longitud de: " + arrayMilNumeros.length);
		/* 
		for(int i = 0; i < arrayMilNumeros.length; i++) {
			System.out.println(arrayMilNumeros[i]);
		}
		*/
		
		//Se pueden hacer arrays de cualquier tipo de dato
		double[] arrayDoubles = new double[5];
		arrayDoubles[0] = 34.56;
		
		boolean[] arrayBooleans = new boolean[3];
		arrayBooleans[2] = false;
		//arrayBooleans[3] = true;//Error en tiempo de ejecución
		
		//Podemos declarar arrays e inicializarlos al mismo tiempo
		char[] arrayCaracteres = {'F','e','l','i','x'};
		//El tamaño de este array es 5
		//El numero de posiciones de este array es 5
		//La primera posición del array tiene de valor: F
		//La última posición del array tiene de valor: x
		//La posición 5 del array tiene de valor: NO EXISTE
		//La posición 4 del array tiene de valor: x
		//La posición 3 del array tiene de valor: i
		
		int[] arrayNumerico2 = {2,4,5,6,7,8};
		//El tamaño de este array es 6
		//El numero de posiciones de este array es 6
		//La primera posición del array tiene de valor: 2
		//La última posición del array tiene de valor: 8
		//La posición 5 del array tiene de valor: 8
		//La posición 6 del array tiene de valor: NO EXISTE
		//La posición 4 del array tiene de valor: 7
		//La posición tercera del array tiene de valor: 5
		//La posición quinta del array tiene de valor: 7
		//La posición septima del array tiene de valor: NO EXISTE
	}

}

public class _0071_BucleFor {
	/*
	 * Otra manera de controlar el flujo del código que no sean los bloques condicionales
	 * es utilizar bucles.
	 * 
	 * Los bucles los vamos a utilizar cuando tenemos que realizar una tarea repetitiva.
	 * 
	 * Todo bucle for empieza con la sentencia "for". Indistintamente de si es for o for-each.
	 */
		
	public static void main(String[] args) {
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		System.out.println("Hola en este tema vamos a hablar de bucles");
		
		/*
		 * Quiero imprimir esta misma frase 10 veces.
		 * No necesito escribir 10 veces el mismo código.
		 * Puedo utilizar un bucle con 10 iteraciones:
		 * 
		 * =================
		 * =   BUCLE FOR   =
		 * =================
		 * 1.- for
		 * 2.- variable de control, generalmente int
		 * 3.- condición. Mientras sea true el bucle se ejecutará
		 * 4.- incremento de la variable de control
		 * 
		 * Las partes 2, 3, 4 van entre paréntesis y separadas por ";"
		 */

		System.out.println("------------------ FOR ---------------------");
		for(int i = 1; i <= 10;i++) { // empeza en 1 y ejecuta mientras sea < ó = a 10.
									  // cuando no cumpla esa condición parará.
			System.out.println("Hola en este tema vamos a hablar de bucles");
		}

		/*
		for (int i = 10; i <= 20; i++) {
			System.out.println("Estoy en la vuelta: " + i);
		}
		*/

		/*
		 * 1.- Variable de control:
		 * Podemos inicializar la variable de control con cualquier valor.
		 * Generalmente, en 0.
		 * Si tenemos una colección y queremos acceder a sus elementos
		 * por sus índices: Java empieza a contar las posiciones desde 0.
		 * 
		 * 2.- Condición:
		 * Verificamos el valor de la variable de control con una condición.
		 * La condición será cualquiera que necesitemos que se cumpla en función
		 * de las necesidades que tengamos.
		 * 
		 * Si la condición se cumple entrará en el bloque de código del bucle.
		 * Cuando termine todas las instrucciones se ejecutará incremento.
		 * 
		 * 3.- Incremento:
		 * El incremento es la tercera parte del paréntesis después de for.
		 * El incremento puede ser cualquier operación aritmética, según
		 * necesite la lógica de nuestro bucle.
		 */

		/*
		 * Primera vuelta del bucle
		 * i = 1 --> inicializamos el bucle con este valor
		 * i <= 10 --> cumple la condición, así que entra en el bucle
		 * System.out.println("Hola en este tema vamos a hablar de bucles");
		 * el siguiente paso es incremento de la variable de control i++
		 * 
		 * Segunda vuelta del bucle
		 * hemos incrementado en 1 unidad la variable de control i, con i++
		 * ahora i = 2
		 * i <= 10 --> cumple la condición, así que entra en el bucle
		 * System.out.println("Hola en este tema vamos a hablar de bucles");
		 * el siguiente paso es incremento de la variable de control i++
		 * 
		 * Tercera vuelta del bucle...
		 * Cuarta vuelta...
		 * ...
		 * 
		 * Décima vuelta del bucle
		 * ahora i = 10
		 * i <= 10 --> cumple la condición, así que entra en el bucle
		 * System.out.println("Hola en este tema vamos a hablar de bucles");
		 * el siguiente paso es incremento de la variable de control i++
		 * 
		 * Ahora va a intentar hacer otra iteración:
		 * i = 11
		 * i <= 10 --> la condición es false, el bucle ya no se va a ejecutar
		 */

		/* 
		 * Cuando ÚNICAMENTE tenemos una sentencia dentro del bucle, igual que con
		 * las condiciones, no hace falta que se utilicen las llaves {}.
		 * 
		 * La primera línea de código, en el ejemplo System.out.println(); formará parte
		 * del bucle, las siguientes no.
		 */
		
		System.out.println("------------------ FOR 100000---------------------");
		for(int i = 1; i <= 100_000;i++) 
			System.out.println("Hola en este tema vamos a hablar de bucles");
		
		/*
		 * Si hay más de una instrucción se necesitan llaves {}
		 * Es recomendable (y hace más claro y legible el código) utilizar 
		 * siempre las llaves {}
		 */

		//Es habitual
		System.out.println("------------------ FOR CON BLOQUE---------------------");
		for(int i = 1; i <= 1_000;i++) {
			System.out.println("Hola en este bucle");	
			System.out.println("Vamos a ejecutar varias sentencias");
		}

		//Complicando el bucle
		System.out.println("------------------ FOR CON BLOQUE + CONDICIONES---------------------");
		for(int i = 1; i <= 1_000;i++) {
			if (i % 2 == 0) {
				System.out.println("Esta vuelta es par.");
			} else {	
				System.out.println("Esta vuelta es impar.");
			}
		}
		
		System.out.println("------------------ FOR USANDO LA VARIABLE DE CONTROL---------------------");
		for(int i = 1; i <= 10; i++) {
			System.out.println("Hola este bucle lo hemos ejecutado " + i);
		}
		
		/*
		 * La variable de control i, creada para controlar las iteraciones del bucle,
		 * no existe fuera del bucle. Su ciclo de vida es el bucle.
		 * Si fuera del bucle intentamos usarla Java nos dará un error.
		 */

		// Descomenta la siguiente línea y verás el tipo de error
		//System.out.println("No puedo acceder a la variable 'i'" + i);
		
		System.out.println("------------------ FOR SOLO PARES---------------------");
		//Imprimir solo los pares
		for(int i = 0; i <= 10;i += 2) {
			System.out.println("Hola este bucle lo hemos ejecutado " + i);
			//i++;//No es buena practica alterar la variable de control de bucle fuera del "for"
		}

		System.out.println("------------------ FOR SOLO PARES---------------------");
		//Imprimir solo los pares
		for(int i = 0; i <= 10;i++) {
			if (i % 2 == 0) {
				System.out.println("Hola este bucle lo hemos ejecutado " + i);
			}
			//i++;//No es buena practica alterar la variable de control de bucle fuera del "for"
		}

		//Normalmente usamos la palabra "iteracion" para referirnos a cada
		//salto del bucle
		
		//Todas las partes del "for" son OPCIONALES
		//for(;;) {
			//OJO, cuidado con bucles que no paran porque podemos hacer
			//un bucle infinto
			//System.out.println("Esto es un bulce infinito");
		//}

		/*
		 * Un bucle infinito se estará ejecutando hasta que los recursos de nuestro
		 * sistema se agoten. CUIDADO: sobrecarga el sistema, entre otros.
		 * 
		 * 1. Consumo de CPU: va a estar utilizando uno de los núcleos del procesador
		 * 					  al 100% para ejecutarlo.
		 * 2. Memory Leaks: si tenemos una colección a la que le vamos añadiendo elementos
		 * 					de manera infinita va a colapsar la RAM.
		 * 3. Bloqueo de programa: si se trabaja con diferentes hilos de ejecución y está
		 * 						   en el hilo principal el programa deja de responder.
		 * 4. Sobrecarga de logs: si dentro del bucle hay escritura a un archivo o consola
		 * 						  se va a llenar el log rápidamente o nos va a dejar sin
		 * 						  espacio el disco.  
		 */
		
		//A veces podemos hacer que no entre en un bucle por error de programacion
		for(int i = 0; i > 1_000;i += 2) {
			System.out.println("Esto no se imprime nunca " + i);
		}
		
		//A veces podemos hacer que bucles infinitos por error
		//Bueno, en este caso se parara cuando llegue al maximo rango del "int"
		/* 
		for(int i = 1001; i > 1_000;i += 1) {
			System.out.println("Esto se imprime muuuuuchas veces " + i);
		}
		*/
		
		/*
		 * =======================
		 * =   RECOMENDACIONES   =
		 * =======================
		 * 
		 * 1.- Escribe la variable de control en un papel para ver cómo va incrementando
		 * 2.- SIEMPRE haz bloques con el uso de las llaves {}, aunque solo sea para
		 *     una sentencia.
		 */
		
		//Podemos declarar la variable de control de bucle fuera del bucle
		int i = 0;
		for(i = 0; i <= 1_000;i += 2) {
			System.out.println("Hola este bucle lo hemos ejecutado " + i);
		}
		System.out.println("Ahora si que puede acceder a la variable de control: " + i);
		
		//Usando bucles podemos resolver de varias maneras los ejercicios
		//jugando con la variable de control y las condiciones de ejecución
		for(int j = 0; j <=9; j++) {
			System.out.println("Hola a todos");
		}
		
		for(int j = 1; j <=10; j++) {
			System.out.println("Hola a todos");
		}
		
		for(int j = 10; j <=20; j++) {
			System.out.println("Hola a todos");
		}
		
		//Las tres maneras anteriores son equivalente, imprimen 10 veces por pantalla
		
		//Podemos seguir usando variables para las condiciones de bucle
		int numero = 10;
		for(int j = 1; j <= numero; j++) {
			System.out.println("Hola 10 veces");
		}

		/*
		 * =======================================
		 * =   DIFERENCIA ENTRE FOR y FOR EACH   =
		 * =======================================
		 */

		// si tengo que repetir una tarea sin recorrer una coleccion (como array)
		// ¿puedo utilizar for-each?
		// NO, hay una excepción --> String
		String texto = "Lorem ipsum";
		// texto.toCharArray() --> char[] texto = {'L','o','r','e','m',' ','i','p','s','u','m'};
		int contarM = 0;
		for (char letra : texto.toCharArray()) { // aplico método toCharArray() a texto
												 // a partir de ahora es un 
			if (letra == 'm') { // quiero imprimir la letra 'm'
				System.out.println(letra);
			}
			// quiero contar cuántas 'm' hay:
			if (letra == 'm') {
				contarM++;
			}
			
			// System.out.println("hay " + contarM + " letras 'm'.");
			
			/*
			 * Si ponemos este print dentro del bucle se va a imprimir
			 * con cada iteración.
			 * La primera vez, con la L, no cumple y el print dirá que hay 0 Ms
			 * La segunda vez, con la o, no cumple y el print dirá que hay 0 Ms
			 * así sucesivamente hasta llegar a la primera 'm'
			 * A partir de ahí, el contador pasará a 1 y cada iteración 
			 * mostrará el print con el mensaje: "hay 1 letras 'm'."
			 */
		}
		System.out.println("hay " + contarM + " letras 'm'."); // este print va fuera del bucle
															   // así solo se imprime una vez con el resultado

		// ======LO MISMO CON BUCLE FOR======
		contarM = 0;
		for (int j = 0; j < texto.length(); j++) {
			/* 
			if (texto.toCharArray()[j] == 'm') {
				contarM++;
			}

			Comento este condicional porque hay una manera más sencilla de hacerlo
			*/
			if (texto.charAt(j) == 'm') {
				contarM++;
			}
		}
		System.out.println("hay " + contarM + " Ms en texto.");
		
		//Podemos invocar funciones dentro de un bucle "for"
		for(int j = 1; j <= numero; j++) {
			imprimirNumero(j);
		}
		
		//De igual manera podemos invocar funciones que hagan bucles for
		imprimirXVecesNumero(10);
		imprimirXVecesNumero(100);
	}
	
	public static void imprimirNumero(int numero) {
		System.out.println("El numero es : " + numero);
	}
	
	public static void imprimirXVecesNumero(int numero) {
		for(int j = 1; j <= numero; j++) {
			imprimirNumero(j);
		}
	}
}

import java.util.Scanner;

public class _0071_BucleWhile {

	/*
	 * En ocasiones no se sabe cuántas veces necesitamos repetir una
	 * misma ejecución.
	 * 
	 * Para ello está while, que es una mezcla entre "for" y condicional "if".
	 * 
	 * La lectura sería "mientras se cumpla esto ejecútate"
	 * A diferencia de for, que también lleva una condición, a "for" lo limitamos
	 * utilizando puntos de control.
	 * 
	 * "while" no tiene ese control y debemos ser cautos con las condiciones
	 * para no hacer bucles infinitos, que es más fácil tenerlo que en el bucle "for"
	 * 
	 * 
	 * La sintaxis de esta sentencia es:
	 * while (CONDICION_BOOLEANA) {
	 *     // bloque de código
	 * }
	 */
	public static void main(String[] args) {
		//El ejemplo más facil sería un bucle infinito
		/*
		while(true)
			System.out.println("Esto es un bucle infinito");
		*/
		
		/*
		 * Mientras que en "for" tenemos la variable de control,
		 * la condición, y el incremento en la misma línea;
		 * while tiene el control fuera del bucle.
		 * 
		 * Dentro del bucle alteraremos esa variable de control
		 * para poder llevar la cuenta y que cambie la condición
		 * a false.
		 */
		
		//Imprimir los 10 primeros números mediante un bucle while
		int numero = 1;
		while(numero <=10) {
			System.out.println(numero++);
		}

		/*
		 * Todo aquello que puedes hacer con "for" lo puedes hacer con "while"
		 * (y a la inversa, pero es poco frecuente).
		 * 
		 * En "while" si no cumple la condición no se va a ejecutar ni una vez,
		 * pero la idea es que si no sabemos cuántas veces se tendrá que repetir
		 * la misma instrucción (como pedir una clave con ciertas características
		 * al usuario y no dejar de pedirla hasta que cumpla todas las condiciones)
		 * debemos utilizar "while" (o do while, si necesitamos que como mínimo se
		 * ejecute una vez).
		 */
		
		numero = 11;
		while(numero <=10) {
			System.out.println("Esto no se ejecutaria ninguna vez");
		}
		
		//Vamos a pedirle un numero al usuario hasta que este entre los valores
		//1 y 10
		Scanner sc = new Scanner(System.in);
		System.out.println("Introduzca un número entre el 1 y el 10, pls :)");
		numero = sc.nextInt();
		while(numero < 1 || numero > 10) {
			System.out.println("El numero es incorrecto");
			System.out.println("Introduzca un número entre el 1 y el 10, pls :)");
			numero = sc.nextInt();
		}
		System.out.println("El numero esta entre 1 y 10");
		
		//Manera equivalente con una variable booleana que hace efecto de "flag"
		boolean correcto = false;//Esta variable hace efecto de "flag" o "bandera"
								 //es decir, va a hacer que se sigua ejecutando
								 //el bucle "while" o no.
								 //En este caso parto de la base en que el usuario
								 //va a introducir mal los datos, por lo tanto
								 //establezco correcto=false
		while(!correcto) {
			System.out.println("Introduzca un número entre el 1 y el 10, pls :)");
			numero = sc.nextInt();
			if(numero <= 10 && numero >= 1) {
				System.out.println("El numero esta entre 1 y 10");
				correcto = true; // al cambiar a true, como en la condición está
								 // negado lo entenderá como false y se parará
								 // el bucle
			}else {
				System.out.println("El numero es incorrecto");
			}			
		}
		sc.close();
	}
}

public class _0073_BucleForEach {

	public static void main(String[] args) {
		// Hay una manera mas sencilla de recorrer arrays sin tener 
		// que usar el for normal, que es el llamado "for-each"
		String[] blackWidow = new String[4];
		blackWidow[0] = "Natasha";
		blackWidow[1] = "Romanoff";
		blackWidow[2] = "+00459876543";
		blackWidow[3] = "Molotov";
		
		/*
		 * ==============================
		 * =   ESTRUCTURA DEL FOREACH   =
		 * ==============================
		 * 
		 * for (<tipo> nomVariable : array) {
		 * 		// nomVariable --> va a contener el valor de cada posición del array.
		 * }
		 */

		for(String s : blackWidow) {
			System.out.println(s);
		}
		
		/*
		 * Con este tipo de bucle no vamos a poder acceder a los diferentes elementos
		 * del array por su índice.
		 * 
		 * ======VENTAJAS======
		 * 1.- Es muy sencillo de recorrer completamente un array por todas sus posiciones.
		 * 2.- Es más rápido de escribir.
		 * 
		 * ======INCONVENIENTES======
		 * 1.- No tenemos acceso al índice.
		 * 2.- No podemos alterar la manera de recorrere el array. Por ejemplo, 
		 * 	   no podemos acceder solamente a los pares.
		 * 
		 * Para solucionar el problema podemos ayudarnos de variables auxiliares,
		 * así podremos controlar el índice.
		 */

		int posicion = 1;
		for(String s : blackWidow) {
			System.out.println(posicion + "-" + s);
			posicion++;
		}

		// lo mismo pero en FOR
		for (int i = 1; i < blackWidow.length; i++){
			System.out.println(i + "-" + blackWidow[i]);
		}

		// lo mismo pero en WHILE
		posicion = 1;
		while (posicion < blackWidow.length) {
			System.out.println(posicion + "-" + blackWidow[posicion]);
		}
	}
}

public class _0074_Break_Continue {

	public static void main(String[] args) {
		/*
		 * Algunas veces nos podremos encontrar con que tenemos que alterar
		 * el flujo de ejecución de los bucles.
		 * 
		 * Para alterar el flujo tenemos dos palabras reservadas:
		 * 1.- break
		 * 2.- continue
		 */

		/* 
		 * =============
		 * =   BREAK   =
		 * =============
		 * Con esta palabra se rompe la ejecución del bucle donde se encuentra,
		 * es decir, sale inmediatamente.
		 */
		
		// Voy a imprimir todos los números naturales del 1 al 7
		for(int i = 1; i <= 10; i++) {
			System.out.println("Numero: " + i);
			if (i == 7) {
				break; // Cuando el número sea 7, dejo de ejecutar el bucle
			}
		}
		// El ejemplo de aquí arriba se puede hacer sin "break" mejorando
		// la condición de parada del bucle (i <= 7)
		for(int i = 1; i <= 7; i++) {
			System.out.println("Numero: " + i);
			}
		
		
		/*
		 * break; --> romperá el bucle en el que se ejecuta,
		 * 			  pero si hay un bucle dentro del bucle
		 * 			  el bucle exterior no se ejecutará.
		 * 
		 * Veremos array de más dimensiones (array que tienen dentro otra array)
		 * Ahí entenderemos mejor la anidación de los bucles.
		 */
		
		System.out.println("---------------- BREAK -------------------------");
		//Vamos a imprimir la tabla de multiplicar de los 5 primeros
		//numeros pero solo los resultados del 1 al 5
		for (int i = 1; i <= 10; i++) { // entra al bucle con un 1
			System.out.println("Tabla de multiplicar del " + i);
			for(int j = 1; j <= 10; j++) { // ejecuta este bucle con i = 1
										   // utiliza j para contar ejecuciones
										   // se ejecutará hasta que j sea <= 10
				System.out.println(j + " x " + i + " es igual a " + (i * j));
				if(j == 5) { // cuando j sea 5 se detendrá este bucle y el bucle superior
							 // pasará a la siguiente iteración, en la que i es 2
					break;//Este "break" rompe el bucle de la "j" NO rompe el bulce "i"
				}
			}
			if(i == 5) {
				break;
			}
		}
		
		System.out.println("------------- CONTINUE --------------------");
		
		//"continue"
		//Esta palabra se usa cuando queremos dejar de ejecutar el código del
		//bucle y queremos pasar a la siguiente iteración. OJO, no rompe
		//completamente la ejecución del bucle
		
		//Imprimir todos los numeros pares del 1 al 10
		for (int i = 1; i <= 10; i++) {
			if(i % 2 == 0) {
				System.out.println("Numero par: " + i);
			}			
		}
		
		System.out.println("------------------------------");
		/* 
		 * Este segundo bucle utiliza continue para hacer lo mismo que el anterior
		 * Si el número es impar entra en el condicional y ejecuta continue;
		 * Esto lo que hace es olvidarse que hay más código dentro del bucle
		 * y salta a la siguiente iteración directamente.
		 */
		for(int i = 1; i <= 10; i ++) {
			if(i % 2 != 0) {
				continue;// Saltamos a la siguiente iteracion del bucle
						 // por lo tanto, no se ejecutaria la linea 85
			}	
			System.out.println("Numero par: " + i);
		}
		
		// Vamos a imprimir la tabla de multiplicar de los 6 primeros
		// numeros pares pero solo los resultados del 1 al 6 pares
		for(int i = 1; i <= 6; i ++) {
			if(i % 2 != 0) {
				continue;//volveriamos a la linea 94
			}
			System.out.println("Tabla de multiplicar del " + i);
			for(int j = 1; j <= 6; j++) {
				if(j % 2 != 0) {
					continue;//volveriamos a la línea 99
				}
				System.out.println(j + " x " + i + " es igual a " + (i * j));
			} // cierra el bucle anidado
		} // cierra el bucle principal
	} // cierra main
} // cierra la clase

/*
 * ===================================================
 * =   DIFERENCIA PRINCIPAL ENTRE BREAK Y CONTINUE   =
 * ===================================================
 * 
 * Estructuras de control de bloques de código:
 * 1.- Condicionales: si la condición da true --> ejecuta el bloque entre {}
 * 2.- Bucles: ejecuta el bloque entre llaves {} repetidamente hasta que se dé
 * 			   una condición
 * 	   - For: cuando sé cuántas repeticiones tengo que hacer
 * 	   - While: cuando no se cuantas repeticiones tengo que hacer
 * 
 * También podemos controlar las iteraciones de nuestros bucles.
 * Palabras break y continue:
 * break --> en la línea que se ejecute se detiene el código y sale de ese bucle
 * 		     y ejecuta el código que haya después del bucle de ese nivel.
 * 
 * continue --> en la línea que se ejecute esta palabra reservada va a darle
 * 				la órden al código que debe ejecutrase desde el principio del bucle
 *				pero en la siguiente iteración
 */


 public class _0075_ArrayBidimensionales {

	public static void main(String[] args) {
		// Los arrays que hemos trabajado anteriormente son también conocidos como 
		// "unidimensionales", por ejemplo podemos guardar el eje de las X.
		
		// Existen también los arrays bidimensionales, para guardar por ejemplo
		// puntos en un eje de coordenadas de X e Y.
		
		int[][] ejeXY = new int[3][3];
		ejeXY[1][1] = 2;
		ejeXY[2][1] = 3;
		ejeXY[0][1] = 4;//Esto da error en tiempo de ejecucción
		
		for(int x = 0; x < ejeXY.length;x++){
			for(int y = 0; y < ejeXY[x].length; y++) {
				System.out.println(ejeXY[x][y]);
			}
		}
		
		String[][] avengers = new String[3][4];
		// Podríamos hacerlo con Arrays
		avengers[0][0] = "Steve";
		avengers[0][1] = "Rogers";
		avengers[0][2] = "+0044789567432";
		avengers[0][3] = "Queens";
		
		avengers[1][0] = "Natasha";
		avengers[1][1] = "Romanoff";
		avengers[1][2] = "+004633434444";
		avengers[1][3] = "Molotov";
		
		avengers[2][0] = "Bruce";
		avengers[2][1] = "Baner";
		avengers[2][2] = "+00558737373";
		avengers[2][3] = "Manhattan";
		
		for(int x = 0; x < avengers.length;x++){
			System.out.println("----- DATOS DEL AVENGER " + (x+1) + " --------------");
			for(int y = 0; y < avengers[x].length; y++) {
				System.out.print(avengers[x][y] + " - ");
			}
			System.out.println();
		}
	}

}

// Voy a usar array y necesito importar para usar ss métodos
import java.util.Arrays;
public class _0080_MetodosString {
    
    public static void main(String[] args) {
        // declaro una constante como separador
        final String SEPARADOR = "------------------------";

        String texto = "  Hola Mundo  ";
        String texto2 = "hola mundo";
        String texto3 = "Bienvenido al curso de Java";

        // length()
        System.out.println(".length()");
        System.out.println(SEPARADOR);
        System.out.println("Longitud: " + texto.length());
        System.out.println();

        // charAt(int index)
        System.out.println(".charAt()");
        System.out.println(SEPARADOR);
        System.out.println("Carácter en la posición 1: " + texto.charAt(1));
        System.out.println();

        // substring(int beginIndex, int endIndex)
        System.out.println(".substring()");
        System.out.println(SEPARADOR);
        System.out.println("Substring (0, 4): " + texto.substring(0, 4));
        System.out.println();

        // toUpperCase() / toLowerCase()
        System.out.println(".toUpperCase()");
        System.out.println(SEPARADOR);
        System.out.println("Mayúsculas: " + texto.toUpperCase());
        System.out.println(".toLowerCase()");
        System.out.println(SEPARADOR);
        System.out.println("Minúsculas: " + texto.toLowerCase());
        System.out.println();

        // equals(Object anObject)
        System.out.println(".equals()");
        System.out.println(SEPARADOR);
        System.out.println("¿texto == texto2?: " + texto.equals(texto2));
        System.out.println();

        // equalsIgnoreCase(String anotherString)
        System.out.println(".equalsIgnoreCase()");
        System.out.println(SEPARADOR);
        System.out.println("¿texto == texto2 (ignorando mayúsculas)?: " 
                            + texto.trim().equalsIgnoreCase(texto2));
        System.out.println();

        // contains(CharSequence s)
        System.out.println(".contains()");
        System.out.println(SEPARADOR);
        System.out.println("¿Contiene 'Mundo'?: " + texto.contains("Mundo"));
        System.out.println();

        // indexOf(String str)
        System.out.println(".indexOf()");
        System.out.println(SEPARADOR);
        System.out.println("Índice de 'Mundo': " + texto.indexOf("Mundo"));
        System.out.println();

        // replace(CharSequence target, CharSequence replacement)
        System.out.println(".replace()");
        System.out.println(SEPARADOR);
        System.out.println("Reemplazar 'Hola' por 'Adiós': " 
                            + texto.replace("Hola", "Adiós"));
        System.out.println();

        // trim()
        System.out.println(".trim()");
        System.out.println(SEPARADOR);
        System.out.println("Sin espacios al principio y final: '" + texto.trim() + "'");
        System.out.println();

        // split(String regex)
        System.out.println(".split()");
        System.out.println(SEPARADOR);
        String[] partes = texto3.split(" ");
        System.out.println("Dividir por espacios: " + Arrays.toString(partes));
        System.out.println();

        // concat(String str)
        System.out.println(".concat()");
        System.out.println(SEPARADOR);
        System.out.println("Concatenación: " + texto.concat("!!!"));
        System.out.println("Recuerda: puedes hacerlo también con el operador \"+\"");
        System.out.println("texto + texto: esto dará una nueva String de ambos\ntextos unidos.");
        System.out.println();

        // isEmpty()
        System.out.println(".isEmpty()");
        System.out.println(SEPARADOR);
        String vacía = "";
        System.out.println("¿Cadena vacía?: " + vacía.isEmpty());
        System.out.println();

        // startsWith(String prefix)
        System.out.println(".startsWith()");
        System.out.println(SEPARADOR);
        System.out.println("¿Empieza por '  Hola'?: " + texto.startsWith("  Hola"));
        System.out.println();

        // endsWith(String suffix)
        System.out.println(".endsWith()");
        System.out.println(SEPARADOR);
        System.out.println("¿Termina en 'Mundo  '?: " + texto.endsWith("Mundo  "));
        System.out.println("¿Termina en 'o   '?: " + texto.endsWith("o   "));
        System.out.println("¿Termina en 'o'?: " + texto.endsWith("o"));
        System.out.println();

        // BONUS: Recordatorio de inmutabilidad
        System.out.println("Texto original (no modificado): '" + texto + "'");
        System.out.println("Para \"guardar\" los cambios que hemos hecho en");
        System.out.println("una variable String: tenemos que reasignar la misma variable");
        System.out.println("o crear una variable nueva, si queremos conservar la original.");
        System.out.println("Cualquier cambio sobre una String genera una String nueva.");
    }
}

import java.util.Random;

public class _0081_ClaseRandom {
	public static void main(String[] args) {
		
		// Con la clase random podemos generar primitivos aleatorios de manera sencilla
		Random rd = new Random();
		
		// Mirar documentación para ver lo que hace
		int numeroEntero = rd.nextInt(1, 11);//generando un numero entre el 1 y el 10
		System.out.println("Numero aleatorio: " + numeroEntero);
		
		double numeroDouble = rd.nextDouble(1.0, 100.0);
		System.out.println("Numero double aleatorio: " + numeroDouble);
		
		// Son llamadas numeros pseudoaleatorios ya que se basan siempre en una semilla
		// incial
		Random rdSemilla = new Random(1000);
		// En este caso, como la semilla es igual en el objeto Random
		// siempre generara los mismos números aleatorios
		numeroEntero = rdSemilla.nextInt(1, 11);
		System.out.println("Numero aleatorio: " + numeroEntero);
		numeroDouble = rdSemilla.nextDouble(1.0, 100.0);
		System.out.println("Numero double aleatorio: " + numeroDouble);
		
	}
}

public class _0082_ClaseMath {

	public static void main(String[] args) {
        /*
		// La clase Math nos va a servir para realizar operaciones matemáticas
		//https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html
		
		// Esta clase todos sus métodos son ESTATICOS, es decir, NO es necesario
		// crear objetos de la clase MATH para invocar sus métodos.
		
		// Ejemplo
		// Si queremos usar la clase RANDOM tenemos que crear un objeto de la
		// clase, y eso se hace con la palabra reservada "new"
		Random rd = new Random();
		rd.nextDouble(1, 100);
		
		// En la clase MATH al ser sus métodos ESTÁTICOS debemos invocarlos
		// directamente desde la clase
		// Ejemplo para obtener una potencia
		double potencia = Math.pow(2, 3);
		// NÓTESE como no hago NEW de la clase MATH
		
		// Podemos obtener el número PI o el número E
		final double constantePI = Math.PI;
		System.out.println(Math.PI);
		
		
		// Devuelve el mayor (cercano al infinito positivo) double
		// que sea mayor igual al argumento y devuelve un int 
		System.out.println(Math.floor(4.99));
		System.out.println(Math.floor(4.01));
		
		// Devuelve el menor (cercano al infinito negativo) double 
		// menor que o igual al argumento y éste es igual a un int.
		System.out.println(Math.ceil(4.99));
		System.out.println(Math.ceil(4.01));
		
		//Devuelve el long más cercano, con redondeo 
		//para una energía positiva
		System.out.println(Math.round(4.99));
		System.out.println(Math.round(4.51));
		System.out.println(Math.round(4.5));
		System.out.println(Math.round(4.49));
		System.out.println(Math.round(4.01));
		
		System.out.println(Math.abs(3));
		System.out.println(Math.abs(-3));
		
		//Otra manera de calcular aleatorios.
		//En este caso te devuelve un número aleatorio entre el 0 y el 1
		System.out.println(Math.random());
		
		//Donde N es el valor máximo. Esto nos genera un número aleatorio
		//entre el 1 y N
		//int numeroAletorio = (int) (Math.random() * n) + 1;
		int numeroAletorio = (int) (Math.random() * 10) + 1;
		System.out.println(numeroAletorio);
		
		//Raiz cuadrada
		System.out.println(Math.sqrt(49));
		
		//Si queremos quedarnos con un número de decimales
		//debemos usar la clase DecimalFormat --> ¡Primero tienes que importarla!
		DecimalFormat df = new DecimalFormat("0.000");
		System.out.println(df.format(Math.PI)); // 3.142
		
		//Podemos convertir cadenas a numeros
		//MUY IMPORTANTE cuando leemos datos de ficheros, bases de datos, etc.
		int numero = Integer.parseInt("50");
		double numero2 = Double.parseDouble("50.67");
		System.out.println(numero);
		System.out.println(numero2);

        */
        // Operación entre dos números aleatorios
        int num1 = (int) (Math.random()*10) +1;
        int num2 = (int) (Math.random()*10) +1;

        int suma = num1 + num2;
        double div = (double) num1 / num2;

        System.out.println("resultado suma: " + suma);
        System.out.println("Resultado div: " + div);
        System.out.println("Resultado div: " + Math.round(div));
        System.out.println("Resultado div: " + Math.floor(div));
        System.out.println("Resultado div: " + Math.ceil(div));
	}

}

public class Ejemplos {
    public static void main(String[] args) {
        int a = 5;
        int b = 5;
        
        // condiciones
        if (a < b) {
            System.out.println("A ES MENOR");
        } else if (a == b) {
            System.out.println("SON IGUALES");
            int c = 10;
            int suma = a + b + c;
            System.out.println(suma);
        } else {
            System.out.println("A ES MAYOR");
        }

        // otras condiciones
        if (esPar(a)) {
            System.out.println("El número " + a + " es par");
            if (a < b) {
                System.out.println("A ES MENOR");
            } else if (a == b) {
                System.out.println("SON IGUALES");
            } else {
                System.out.println("A ES MAYOR");
            }
        } else {
            System.out.println("Como que A no es par, no hago nada");
        }

        System.out.println("he mirado todas las condiciones");
        suma += 5; // suma aquí no existe porque solo existe dentro del bloque condicional
        System.out.println(suma);
    }

    public static boolean esPar(int numero) {
        if (numero % 2 == 0) {
            return true;
        } else {
            return false;
        }
    }
}

public class Ejemplos {
    public static void main(String[] args) {
        int a = 5;
        int b = 5;
        
        // condiciones
        if (a < b) {
            System.out.println("A ES MENOR");
        } else if (a == b) {
            System.out.println("SON IGUALES");
            int c = 10;
            int suma = a + b + c;
            System.out.println(suma);
        } else {
            System.out.println("A ES MAYOR");
        }

        // otras condiciones
        if (esPar(a)) {
            System.out.println("El número " + a + " es par");
            if (a < b) {
                System.out.println("A ES MENOR");
            } else if (a == b) {
                System.out.println("SON IGUALES");
            } else {
                System.out.println("A ES MAYOR");
            }
        } else {
            System.out.println("Como que A no es par, no hago nada");
        }

        System.out.println("he mirado todas las condiciones");
        suma += 5; // suma aquí no existe porque solo existe dentro del bloque condicional
        System.out.println(suma);
    }

    public static boolean esPar(int numero) {
        if (numero % 2 == 0) {
            return true;
        } else {
            return false;
        }
    }
}

import java.util.Calendar;
public class FechasCalendar {
    public static void main(String[] args) {
        // Calendar es la clase y hay que instanciar un objeto
        // Uso del metodo getInstance() que devuelve fecha y hora
        // Similar a new Date()
        Calendar fecha = Calendar.getInstance();
        System.out.println("Fecha actual: " + fecha.getTime()); // Devuelve la fecha actual en el momento de la ejecución
        System.out.println();
        /* Se puede obtener la fecha en milisegundos.
         * La variable fecha lo que tiene guardado es la cantidad de milisegundos transcurridos
         * desde la hora UNIX hasta el momento actual.
         * HORA UNIX --> 01/01/1970 00:00:00
         * Se guarda en un tipo numérico long.
         */
        System.out.println("Fecha actual en milisegundos: " + fecha.getTimeInMillis());
        System.out.println();

        /* Podemos extraer día, mes, año, hora, minutos, segundos...
         * Se mantienen para que haya compatibilidad entre nuevas versiones de Java y código más antiguo
         * Es mejor usar la API actual --> java.time
         */
        
        // ----------
        //    Día --> devolverá un número entero que es el día del mes o de la semana
        // ----------
        // 1. Calendar.DAY_OF_WEEK --> devuelve entero entre 1 y 7 correspondiendo al día de la semana
        // Empieza a contar desde 1 y el primer día es domingo
        // 1 = domingo, 2 = lunes, 3 = martes...
        System.out.println("Hoy es día: " + fecha.get(Calendar.DAY_OF_WEEK) + " ¿a qué día de la semana corresponde?");
        // 2. Calendar.DAY_OF_MONTH --> devuelve un entero que corresponde al día numérico dentro del mes
        // Entre 1 y 31 || 1 y 30 || 1 y 29 || 1 y 28 según corresponda
        System.out.println("Hoy es día: " + fecha.get(Calendar.DAY_OF_MONTH));
        System.out.println();
        
        // ----------
        //    Mes --> devolverá un número entero que es el número del mes
        // ----------
        // CUIDADO: empieza a contar desde 0, algo confuso ¿no?
        // 0 = enero, 1 = febrero...
        System.out.println("Estamos en el mes: " + fecha.get(Calendar.MONTH));
        // Para evitar confusión hay que adaptar el resultado
        System.out.println("El mes actual corregido (sumando 1): " + (fecha.get(Calendar.MONTH) + 1));
        System.out.println();

        // ----------
        //    Año --> devolverá un número entero que es el año
        // ----------
        // Devuelve el año actual sin tener que hacer ninguna corrección posterior como pasa con java.util.Date
        System.out.println("Estamos en el año: " + fecha.get(Calendar.YEAR));
        System.out.println();

        // -----------
        //    Hora --> devolverá un número entero con la hora del momento actual.
        // -----------
        // 1. OPCION 1: Horas de 1 a 12 formato de 12h
        System.out.println("La hora actual es (HOUR formato 12h): " + fecha.get(Calendar.HOUR));
        // 2. OPCION 2: Horas de 0 a 23 formato de 24h
        System.out.println("La hora actual es (HOUR_OF_DAY formato 24h): " + fecha.get(Calendar.HOUR_OF_DAY));
        System.out.println();

        // -----------
        //    Minuto --> devolverá un número entero con los minutos del momento actual.
        // -----------
        // El resultado va de 0 a 59
        System.out.println("Los minutos actuales son: " + fecha.get(Calendar.MINUTE));
        System.out.println();

        // ---------------
        //    Segundos --> devolverá un número entero con los segundos del momento actual.
        // ---------------
        // El resultado va de 0 a 59
        System.out.println("Los segundos actuales son: " + fecha.get(Calendar.SECOND));
        System.out.println();

        // -------------------
        //    Milisegundos --> devolverá un número entero con los milisegundos del segundo actual.
        // -------------------
        // El resultado va de 0 a 999
        System.out.println("Los milisegundos actuales son: " + fecha.get(Calendar.MILLISECOND));
        System.out.println();

        System.out.println("------------------------------");
        System.out.println("        MODIFICACIONES ");
        System.out.println("------------------------------");
        System.out.println();

        /*
         * Calendar permite modificar las fechas con el método set()
         * El método set() tiene dentro distintos parámetros que servirán para modificar esas partes de la fecha
         * 
         * set(Año, Mes, Dia, Hora, Minuto, Segundo)
         * 
         * No es necesario dar un argumento (valor) a cada uno de los parámetros.
         * Set únicamente modificará aquella parte de la fecha cuyo parámetro tenga valor.
         */
        System.out.println("Recordemos la fecha: " + fecha.getTime());
        // Modificación de fecha:
        fecha.set(Calendar.YEAR, 2023);
        System.out.println("Vamos a modificar el año poniéndolo en 2023: " + fecha.getTime());
        System.out.println();
        
        // Se pueden hacer varias modificaciones al mismo tiempo. Vamos a cambiar:
        // Año = 2025
        // Mes = Abril
        // Dia = 3
        // Hora = 2
        // Minuto = 13
        // Segundos = 33
        // Modificación de fecha:
        fecha.set(2025, Calendar.APRIL, 3, 2, 13, 33);
        // fecha.set(2025, 3, 3, 2, 13, 33); --> El mes se puede poner en número, recuerda que 0=enero, 3=abril
        System.out.println("Cambiamos varios valores a la vez: " + fecha.getTime());
        System.out.println();

        /*
         * ====ADVERTENCIA====
         * Modificar las fechas erróneamente no va a hacer saltar un error.
         * Si a febrero le asignamos el día 30 saltará al mes siguiente.
         * Esto supone un problema porque podemos estar trabajando con fechas incorrectas.
         */

        System.out.println("---------------------------");
        System.out.println("        OPERACIONES ");
        System.out.println("---------------------------");
        System.out.println();

        /* 
         * java.util.Date no permitía operar con fechas, ni añadir ni sustraer días o meses.
         * Esto con java.util.Calendar se empezó a poder hacer, pero de manera del todo intuitiva.
         * 
         * Hay dos métodos para modificar las fechas: add() y roll().
         * 
         * ---add()---
         * Modifica la fecha de tal manera que si rebasa el mes, va a modificar también el mes.
         * Por ejemplo, tenemos fecha 31-01-2025 y queremos añadir 1 día. 
         * Pasaría a 32-01-2025 que no existe, así que salta a día 01, pero no solo estamos modificando
         * día, como ha rebasado la capacidad del mes 01 también modificará el mes pasando a 02.
         * La fecha resultante después de añadir 1 día a 31-01-2025 será 01-02-2025.
         * 
         * ---roll()---
         * Únicamente modifica la parte de la fecha deseada sin alterar el resto.
         * Por ejemplo, tenemos fecha 03-12-2024 y queremos sumar 1 mes.
         * Es el último mes y no existe el mes 13, así que saltará al mes 01.
         * roll() no va a modificar ninguna otra parte de la fecha:
         * la fecha resultante después de añadir 1 mes con roll() será 03-01-2024.
         *
         * *** Mientras que add() hubiera cambiado el año, roll() únicamente ha cambiado el mes.
         */
        
        // Reset de la fecha para volver a tener la fecha actual:
        fecha = Calendar.getInstance();
        System.out.println("METODO ADD");
        System.out.println("Añadiendo un día a la fecha actual: " + fecha.getTime());
        fecha.add(Calendar.DAY_OF_MONTH, 1);
        System.out.println("Nueva fecha con un día añadido: " + fecha.getTime());
        System.out.println();
        System.out.println("Si le añadimos 5 días saltará de mes (fecha tal como está): " +fecha.getTime());
        fecha.add(Calendar.DAY_OF_MONTH, 15);
        System.out.println("Fecha modificada: " + fecha.getTime());
        System.out.println();
        System.out.println("*********************");
        System.out.println();
        System.out.println("METODO ROLL");
        // Reset de la fecha para volver a tener la fecha actual:
        fecha = Calendar.getInstance();
        System.out.println("Añadiendo 6 días a la fecha actual: " + fecha.getTime());
        fecha.roll(Calendar.DAY_OF_MONTH, 15);
        System.out.println("Nueva fecha con seis días añadidos: " + fecha.getTime());
        System.out.println();
        /*
         * Con la suma de días que hemos hecho tendríamos que pasar a abril, pero lo único
         * que se modifica es el día.
         */


        /* 
         * java.util Calendar --> clase introducida en Java 1.1 (1997).
         * La finalidad era mejorar la anterior clase Date.
         * Date tenía métodos obsoletos, además que no permitía hacer operaciones.
         * Tampoco manejaba correctamente las diferentes zonas horarias.
         * Aunque solucionaba parte de esos problemas, seguía siendo poco intuitivo (meses que empiezan en 0...)
         * En Java 8+ llega el paquete java.time que introduce diferentes clases
         * que permiten trabajar con fechas de una manera mucho más moderna e intuitiva.
         */
        
    }
}



import java.util.Date;
public class FechasDate {
    public static void main(String[] args) {
        // Date es la clase y hay que instanciar un objeto
        Date fecha = new Date();
        System.out.println("Fecha actual: " + fecha); // Devuelve la fecha actual en el momento de la ejecución

        /* Se puede obtener la fecha en milisegundos.
         * La variable fecha lo que tiene guardado es la cantidad de milisegundos transcurridos
         * desde la hora UNIX hasta el momento actual.
         * HORA UNIX --> 01/01/1970 00:00:00
         * Se guarda en un tipo numérico long.
         */
        System.out.println("Fecha actual en milisegundos: " + fecha.getTime());

        /* Podemos extraer día, mes, año, hora, minutos, segundos...
         * No obstante todo ello está deprecado. En el momento de compilar saldrá un warning
         * Se mantienen para que haya compatibilidad entre nuevas versiones de Java y código más antiguo
         * Se debe usar la metodología actual --> java.time
         */
        
        // ----------
        //    Día --> devolverá un número entero que es el día del mes o de la semana
        // ----------
        // 1. getDay() --> devuelve entero entre 0 y 6 correspondiendo al día de la semana
        // Empieza a contar desde 0 y el primer día es domingo
        // 0 = domingo, 1 = lunes, 2 = martes...
        System.out.println("Hoy es día: " + fecha.getDay() + " ¿a qué día de la semana corresponde?");
        // 2. getDate() --> devuelve un entero que corresponde al día numérico dentro del mes
        // Entre 1 y 31 || 1 y 30 || 1 y 29 || 1 y 28 según corresponda
        System.out.println("Hoy es día: " + fecha.getDate());
        
        // ----------
        //    Mes --> devolverá un número entero que es el número del mes
        // ----------
        // CUIDADO: empieza a contar desde 0, algo confuso ¿no?
        // 0 = enero, 1 = febrero...
        System.out.println("Estamos en el mes: " + fecha.getMonth());
        // Para evitar confusión hay que adaptar el resultado
        System.out.println("El mes actual corregido (sumando 1): " + (fecha.getMonth() + 1));

        // ----------
        //    Año --> devolverá un número entero que es el año, pero hay que añadirle 1900
        // ----------
        // Resultado + 1900 = año actual
        // Fue una decisión de los años 90, representar los años como un desplazamiento desde 1900
        // Ejemplo: el año 1965 nos lo mostrará como 65.
        // Ejemplo: el año 2150 nos lo mostrará como 250.
        System.out.println("Estamos en el año: " + fecha.getYear());
        System.out.println("Le añadimos 1900 al año para tener la información correcta: " + (fecha.getYear() + 1900));
        // Por estos problemas ya en Java 1.1 se desaconsejó su uso para pasar a usar java.util.Calendar


        // -----------
        //    Hora --> devolverá un número entero con la hora del momento actual.
        // -----------
        // El resultado va de 0 a 23
        System.out.println("La hora actual es: " + fecha.getHours());

        // -----------
        //    Minuto --> devolverá un número entero con los minutos del momento actual.
        // -----------
        // El resultado va de 0 a 59
        System.out.println("Los minutos actuales son: " + fecha.getMinutes());

        // -----------
        //    Segundos --> devolverá un número entero con los segundos del momento actual.
        // -----------
        // El resultado va de 0 a 59
        System.out.println("Los segundos actuales son: " + fecha.getSeconds());

        /* 
         * La versión Java 1.0 es de 1996. Introdujo clases como String o Random.
         * Pero por los sistemas de ese momento, principalmente, funcionaban en UNIX.
         * Esa fue la orientación que se le dio a Java. 
         * Pronto quedó obsoleto y nació la clase Calendar en Java 1.1 en 1997
         */

    }
}




        
        /*
 * ============
 * =   TIME   =
 * ============
 * 
 * El paquete time aparece con Java 8 y mejora las clases Date y Calendar.
 * 
 * Dentro del paquete time tenemos diferentes clases para gestionar el tiempo y las fechas.
 * 
 * ====ENLACE====
 * https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html
 * 
 * Voy a ejemplificar qué se puede hacer con las fechas para que os ayude a comprender su funcionamiento.
 * Principalmente voy a mostraros las diferentes clases de fecha que hay (Date, Time, DateTime, ZonedDateTime)
 * Cómo se pueden modificar las fechas y operar con ellas.
 * Cómo se les puede dar formato.
 * Comprobar lapsos de tiempo con Duration y Period.
 * 
 * Se pueden hacer muchísimas más cosas y es importante que invirtáis tiempo para jugar y explorar
 * los distintos métodos y cómo funcionan.
 * 
 * ===============
 * =   METODOS   =
 * ===============
 * 
 * .of...() --> para instanciar explícitamente con los valores deseados
 * .parse() --> para "traducir" fecha u hora que es una String que es una fecha a una clase de fecha
 * .get...() --> extraer partes de la fecha, hora, zona...
 * .is...() --> para comprobaciones
 * .with...() --> genera un objeto nuevo de fecha con un valor específico, como crear una copia con un cambio
 * .plus...() --> añadir tiempo, sumar
 * .minus...() --> quitar tiempo, restar
 * .to...() --> convertir fecha de una clase a otra
 * .at...() --> combinar diferentes objetos de tiempo para tener uno más completo
 */

import java.time.DayOfWeek;
import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Month;
import java.time.Period;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter; // fecha local

public class FechasTime {
    public static void main(String[] args) {

        /*
         * ===============
         * =   FORMATO   =
         * ===============
         * Voy a dejar varios formatos preparados.
         * En cada caso habrá un ejemplo de cómo puede entrar una String y "traducirla" con un formato concreto.
         * 
         * |                               TABLA DE PATRONES MAS USADOS                               |
         * |--------|-------------------------|---------------------|---------------------------------|
         * |SIMBOLO | SIGNIFICADO             | EJEMPLO DE SALIDA	| COMENTARIO                      |
         * |--------|-------------------------|---------------------|---------------------------------|
         * | y	    | Año	                  | 2025, 25	        | yy (2 dígitos), yyyy (4 dígitos)|
         * | M (m)  | Mes	                  | 3, 03, Mar, March	| M, MM, MMM, MMMM                |
         * | d	    | Día del mes	          | 5, 05, 25	        | d (1–31)                        |
         * | E (m)  | Día de la semana	      | Mon, Monday	        | E, EEE, EEEE                    |
         * | H (m)  | Hora (0–23)	          | 0 a 23	            | 24h formato                     |
         * | h	    | Hora (1–12)	          | 1 a 12	            | 12h formato con AM/PM           |
         * | m	    | Minutos	              | 0 a 59	            |                                 |
         * | s	    | Segundos	              | 0 a 59              |                                 | 	
         * | S (m)  | Milisegundos	          | 987	                | hasta 3 dígitos                 |
         * | a	    | AM/PM	                  | AM, PM	            |                                 |
         * | z	    | Zona horaria	          | CET, PST, etc.	    | abreviatura de zona horaria     |
         * | Z (m)	| Offset de zona horaria  | +0100, -0500	    | offset sin :                    |
         * | XXX	| Offset con dos puntos	  | +01:00, -05:00	    | estilo ISO                      |
         * |--------|-------------------------|---------------------|---------------------------------| 
         * 
         * En esta tabla tenéis un resumen de cómo hay que escribir el patrón de la fecha para darle formato.
         * (m) --> significa que esa letra es mayúscula.
         */

        // Formato Date
        DateTimeFormatter formatoFecha = DateTimeFormatter.ofPattern("dd/MM/yyyy");
        // Formato Time
        DateTimeFormatter formatoHora = DateTimeFormatter.ofPattern("HH:mm:ss");
        // formato DateTime
        DateTimeFormatter formatoDateTime = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        // Formato ZonedDateTime
        DateTimeFormatter formatoZonedDateTime = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss Z z");


        /*
         * =================================
         * =   DIFERENTES TIPOS DE FECHA   =
         * =================================
         * En las siguientes líneas voy a almacenar en diferentes variables LA HORA ACTUAL según las diferentes clases.
         * De todas ellas voy a sacar un print por pantalla en el momento que esté utilizando cualquiera de ellas.
         * Aquí lo que vas a ver es cómo sacar la fecha actual en las clases principales.
         */

        // Clase Date
        LocalDate fechaDate = LocalDate.now();
        // Clase Time
        LocalTime horaTime = LocalTime.now();
        // Clase DateTime
        LocalDateTime fechaDateTime = LocalDateTime.now();
        // Clase ZonedDateTime
        ZonedDateTime fechaZonedDateTime = ZonedDateTime.now();

        /*
         * =================
         * =   LocalDate   =
         * =================
         * 
         * Ya sabes cómo tener la fecha actual, pero: 
         * 1. qué pasa si la fecha viene de una cadena de texto
         * 2. qué pasa si lo que quieres es una fecha puesta manualmente
         */

        System.out.println("======LocalDate======");
        System.out.println("Vamos a ver primero la fecha actual: " + fechaDate);
        System.out.println();

        // ======FECHA EN CADENA DE TEXTO======
        String fechaString = "06/06/1966"; // esto es una String
        // Se ha declarado anteriormente formatoFecha dia/mes/año
        // Se puede "traducir" (parsear) la cadena de texto a fecha
        System.out.println("Entra una String que es una fecha que queremos convertir: " + fechaString);
        LocalDate fechaDateParse = LocalDate.parse(fechaString, formatoFecha);
        System.out.println("Se ha parseado la fecha y ahora es de la clase LocalDate");
        System.out.println("fecha parseada: " + fechaDateParse);
        System.out.println();

        // ======FECHA ASIGNADA "MANUALMENTE"======
        LocalDate fechaManual = LocalDate.of(1966, 06, 06);
        System.out.println("La siguiente fecha ha sido asignada de forma manual: " + fechaManual);
        System.out.println();

        /*
         * Ahora hay dos fechas:
         * 1. La fecha actual en el momento de ejecución.
         * 2. La fecha que se ha asignado manualmente en String o directamente como LocalDate: 06/06/1966
         * 
         * Veamos lo siguiente:
         * - Cómo comparar.
         * - Cómo manipularlas (sumando y restando).
         * - Cómo coger únicamente partes de la fecha, como puede ser el año, mes, día...
         */

        // ======COMPARACION ENTRE FECHAS======
        System.out.println("======COMPARACION ENTRE FECHAS======");
        System.out.println("Fecha actual: " + fechaDate);
        System.out.println("Fecha introducida manualmente: " + fechaManual);

        // Voy a ver si una fecha es anterior a la otra
        // Para esto están los métodos isBefore e isAfter (antes y después respectivamente)
        // Utilizar este método devuelve un boolean
        boolean anterior = fechaManual.isBefore(fechaDate); // true
        System.out.println("¿Es la fecha '" + fechaManual + "' anterior a la fecha '" + fechaDate + "'?: " + anterior);
        boolean posterior = fechaManual.isAfter(fechaDate); // false
        System.out.println("¿Es la fecha '" + fechaManual + "' posterior a la fecha '" + fechaDate + "'?: " + posterior);
        System.out.println();

        /*
         * ======OPERACIONES CON FECHAS======
         * Para poder hacer diferentes operaciones están los métodos que empiezan por:
         * - plus (sumar)
         * - minus (restar)
         * 
         * Se pueden añadir días, meses, años, minutos, etc.
         * 
         * Para hacer las diferentes operaciones hay distintos métodos.
         * LocalDate es una clase que solo tiene en cuenta la fecha (año-mes-dia)
         * A LocalDate se le pueden añadir/quitar años, meses, semanas, días
         */

        System.out.println("======OPERACIONES CON FECHAS======");
        System.out.println("Fecha sin manipular: " + fechaDate);
        LocalDate fechaDateAddDia = fechaDate.plusDays(10); // añade 10 días a la fecha
        System.out.println("Se han añadido 10 días a '" + fechaDate + "' obteniendo como resultado: " + fechaDateAddDia);
        LocalDate fechaDateQuitarMes = fechaDate.minusMonths(5); // quita 5 meses a la fecha
        System.out.println("Se han substraído 5 meses a '" + fechaDate + "' obteniendo como resultado: " + fechaDateQuitarMes);
        System.out.println("Cada operación tiene su método, no olvides tener siempre a mano el manual. :)");
        System.out.println();

        /*
         * ======EXTRAER PARTES DE FECHAS======
         * Se pueden obtener partes de las fechas como el año, el mes, el día, etc.
         * Los métodos para ello empiezan por get
         */

        System.out.println("======EXTRAER PARTES DE FECHAS======");
        System.out.println("Fecha inicial: " + fechaDate);
        // Los días como mucho van a llegar a 31
        // Los meses como mucho van a llegar a 12
        // Los años son más grandes
        // Todos son números enteros, podemos almacenar los días y meses como byte
        // Aunque por lo general, para evitar problemas de tamaño (dado el tipado estático de Java)
        // Cuando hacemos operaciones con los números necesitamos que sean int
        // Así que por comodidad vamos a utilizar int, ya que es más seguro, sencillo y compatible
        // utilizar siempre este tipo.
        int diaMes = fechaDate.getDayOfMonth();
        int diaAnio = fechaDate.getDayOfYear();
        DayOfWeek diaSemana = fechaDate.getDayOfWeek();
        int mes = fechaDate.getMonthValue();
        Month mesNombre = fechaDate.getMonth();
        int anio = fechaDate.getYear();
        System.out.println("Dentro de la fecha el día es: " + diaMes);
        System.out.println("Teniendo en cuenta los 365 días del año este es el día número: " + diaAnio);
        System.out.println("Hoy es: " + diaSemana);
        System.out.println("Dentro de la fecha el mes es: " + mes);
        System.out.println("El nombre de este mes es: " + mesNombre);
        System.out.println("Estamos en el año: " + anio);
        System.out.println();

        /* 
         * =================
         * =   LocalTime   =
         * =================
         * 
         * ======HORA EN CADENA DE TEXTO======
         * Para traducir una hora en String a LocalTime el proceso es el mismo visto en LocalDate.
         * 
         * ======HORA ASIGNADA "MANUALMENTE"======
         * Para hacer una asignación de hora manual el proceso es el mismo visto en LocalDate.
         * 
         * ======COMPARACION ENTRE HORAS======
         * Para verificar si un tiempo es anterior o posterior se hace igual que con LocalDate (isBefore/isAfter).
         * 
         * ======OPERACIONES CON HORAS======
         * Funciona del mismo modo:
         * - plus para añadir
         * - minus para substraer
         * 
         * Según qué sea lo que se desea modificar se deberá aplicar uno u otro método.
         * 
         * ======EXTRAER PARTES DE FECHAS======
         * Se puede extraer cualquier parte de la hora igual que de la fecha.
         * El procedimiento es el mismo, salvo que no será con años, días, meses... 
         * Es con Hour, Minute, Second, Nano...
         */

        /*
         * =====================
         * =   LocalDateTime   =
         * =====================
         * 
         * Se utiliza la misma lógica teniendo en cuenta que esta clase se puede entender como Date + Time
         */

        /* 
         * =====================
         * =   ZonedDateTime   =
         * =====================
         * 
         * Incluye zona horaria.
         * Todo funciona igual, pero me detengo a mostrar las zonas horarias.
         */
        System.out.println("=====================");
        System.out.println("=   ZonedDateTime   =");
        System.out.println("=====================");
        System.out.println();
        System.out.println("Recordatorio de la fecha entera: " + fechaZonedDateTime);
        // Cambio de la información al huso horario de Tokio
        // Podéis consultar las diferentes zonas aquí: https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html
        ZonedDateTime fechaZonedDateTimeTokio = fechaZonedDateTime.withZoneSameLocal(ZoneId.of("Asia/Tokyo"));
        System.out.println("Fecha en la zona horaria de Tokio: " + fechaZonedDateTimeTokio);
        // CUIDADO --> así cambias la zona con la MISMA HORA LOCAL (la nuestra)

        // Si se utiliza el método que tiene en cuenta el INSTANTE sí que va a transformar la hora
        // Un instante es único en cualquier parte del mundo que te encuentres.
        fechaZonedDateTimeTokio = fechaZonedDateTime.withZoneSameInstant(ZoneId.of("Asia/Tokyo"));
        System.out.println("Fecha transformada para este mismo momento en el horario de Tokio: " + fechaZonedDateTimeTokio);
        System.out.println();

        // Revisando, si podemos extraer lo que queramos de una fecha será fácil quedarnos fecha y hora (DateTime)
        // para mostrarle al usuario algo más amable ¿no?
        
        // ======CAMBIO DE FORMATO======
        System.out.println("Este formato cuesta de entender para un usuario normal. Se procede a simplificarlo...");
        // Java es de tipado estático. La variable fechaZonedDateTimeTokio se ha declarado como ZonedDateTime
        // Necesitamos una variable nueva de la clase LocalDateTime para poder alojar la fecha
        LocalDateTime fechaLocalDateTimeTokio = fechaZonedDateTimeTokio.toLocalDateTime();
        System.out.println("En el horario de Tokio es: " + fechaLocalDateTimeTokio);
        // Sigue sin mostrarse tan bien como quisiéramos. Formato...
        // fechaLocalDateTimeTokio.format(formatoDateTime); --> Esto devuelve una String
        // Es mejor hacerlo directamente en la sentencia de salida y no utilizar más variables innecesarias.
        System.out.println("Corregido: " + fechaLocalDateTimeTokio.format(formatoDateTime));
        System.out.println();

        /*
         * =========================
         * =   DURATION y PERIOD   =
         * =========================
         * 
         * Se pueden crear duraciones de tiempo basadas en segundos con la clase Duration
         * o en fechas con la clase Period.
         * 
         * También se puede calcular el tiempo transcurrido entre fechas u horas utilizando el método between.
         */

        System.out.println("=========================");
        System.out.println("=   DURATION Y PERIOD   =");
        System.out.println("=========================");
        System.out.println();
        System.out.println("======PERIOD======");
        System.out.println("Fecha actual: " + fechaDate);
        System.out.println("Fecha creada: " + fechaManual);
        System.out.println();
        // La diferencia entre una y otra será de la clase Period
        Period diferenciaFecha = Period.between(fechaManual, fechaDate);
        System.out.println("El tiempo transcurrido entre ambas fechas es de: ");
        System.out.println("Días: " + diferenciaFecha.getDays());
        System.out.println("Meses: " + diferenciaFecha.getMonths());
        System.out.println("Años: " + diferenciaFecha.getYears());
        System.out.println();
        System.out.println("======DURATION======");
        System.out.println("Hora actual: " + horaTime.format(formatoHora));
        // No hemos creado antes una hora, podemos hacerlo ahora:
        LocalTime horaManual = LocalTime.of(22, 45, 30);
        System.out.println("Hora creada: " + horaManual);
        System.out.println();
        // La diferencia, al ser tiempo y no fecha, será de la clase Duration
        Duration diferenciaHora = Duration.between(horaTime, horaManual);
        System.out.println("El tiempo transcurrido entre ambas es de:");
        System.out.println("Segundos: " + diferenciaHora.getSeconds());
        System.out.println("Nanosegundos: " + diferenciaHora.getNano());
        System.out.println();

        /*
         * ======OPERACIONES CON PERIODOS======
         * También se pueden hacer operaciones utilizando los métodos plus y minus para añadir o substraer
         * 
         * Vamos a crear un Periodo para añadir o quitar a una fecha.
         * También vamos a hacer lo mismo con una duración para hacerlo con una hora.
         */

        System.out.println("======OPERACIONES======");
        // Creo tanto periodo como duracion
        Duration duracionOperaciones = Duration.ofHours(5); // Esto simplemente es una duración de 5h
        Period periodoOperaciones = Period.ofWeeks(2); // Esto en cambio es una duración de 2 semanas
        System.out.println("Periodo y duración establecidos...");
        System.out.println("A la hora '" + horaTime.format(formatoHora) + "' le voy a añadir la duración.");
        System.out.println("La hora actualizada es: " + horaTime.plus(duracionOperaciones).format(formatoHora));
        System.out.println();
        System.out.println("A la fecha '" + fechaDate + "' le voy a quitar el periodo.");
        System.out.println("La fecha actualizada es: " + fechaDate.minus(periodoOperaciones));
        


        



        // // Calendar es la clase y hay que instanciar un objeto
        // // Uso del metodo getInstance() que devuelve fecha y hora
        // // Similar a new Date()
        // Calendar fecha = Calendar.getInstance();
        // System.out.println("Fecha actual: " + fecha.getTime()); // Devuelve la fecha actual en el momento de la ejecución
        // System.out.println();
        // /* Se puede obtener la fecha en milisegundos.
        //  * La variable fecha lo que tiene guardado es la cantidad de milisegundos transcurridos
        //  * desde la hora UNIX hasta el momento actual.
        //  * HORA UNIX --> 01/01/1970 00:00:00
        //  * Se guarda en un tipo numérico long.
        //  */
        // System.out.println("Fecha actual en milisegundos: " + fecha.getTimeInMillis());
        // System.out.println();

        // /* Podemos extraer día, mes, año, hora, minutos, segundos...
        //  * Se mantienen para que haya compatibilidad entre nuevas versiones de Java y código más antiguo
        //  * Es mejor usar la API actual --> java.time
        //  */
        
        // // ----------
        // //    Día --> devolverá un número entero que es el día del mes o de la semana
        // // ----------
        // // 1. Calendar.DAY_OF_WEEK --> devuelve entero entre 1 y 7 correspondiendo al día de la semana
        // // Empieza a contar desde 1 y el primer día es domingo
        // // 1 = domingo, 2 = lunes, 3 = martes...
        // System.out.println("Hoy es día: " + fecha.get(Calendar.DAY_OF_WEEK) + " ¿a qué día de la semana corresponde?");
        // // 2. Calendar.DAY_OF_MONTH --> devuelve un entero que corresponde al día numérico dentro del mes
        // // Entre 1 y 31 || 1 y 30 || 1 y 29 || 1 y 28 según corresponda
        // System.out.println("Hoy es día: " + fecha.get(Calendar.DAY_OF_MONTH));
        // System.out.println();
        
        // // ----------
        // //    Mes --> devolverá un número entero que es el número del mes
        // // ----------
        // // CUIDADO: empieza a contar desde 0, algo confuso ¿no?
        // // 0 = enero, 1 = febrero...
        // System.out.println("Estamos en el mes: " + fecha.get(Calendar.MONTH));
        // // Para evitar confusión hay que adaptar el resultado
        // System.out.println("El mes actual corregido (sumando 1): " + (fecha.get(Calendar.MONTH) + 1));
        // System.out.println();

        // // ----------
        // //    Año --> devolverá un número entero que es el año
        // // ----------
        // // Devuelve el año actual sin tener que hacer ninguna corrección posterior como pasa con java.util.Date
        // System.out.println("Estamos en el año: " + fecha.get(Calendar.YEAR));
        // System.out.println();

        // // -----------
        // //    Hora --> devolverá un número entero con la hora del momento actual.
        // // -----------
        // // 1. OPCION 1: Horas de 1 a 12 formato de 12h
        // System.out.println("La hora actual es (HOUR formato 12h): " + fecha.get(Calendar.HOUR));
        // // 2. OPCION 2: Horas de 0 a 23 formato de 24h
        // System.out.println("La hora actual es (HOUR_OF_DAY formato 24h): " + fecha.get(Calendar.HOUR_OF_DAY));
        // System.out.println();

        // // -----------
        // //    Minuto --> devolverá un número entero con los minutos del momento actual.
        // // -----------
        // // El resultado va de 0 a 59
        // System.out.println("Los minutos actuales son: " + fecha.get(Calendar.MINUTE));
        // System.out.println();

        // // ---------------
        // //    Segundos --> devolverá un número entero con los segundos del momento actual.
        // // ---------------
        // // El resultado va de 0 a 59
        // System.out.println("Los segundos actuales son: " + fecha.get(Calendar.SECOND));
        // System.out.println();

        // // -------------------
        // //    Milisegundos --> devolverá un número entero con los milisegundos del segundo actual.
        // // -------------------
        // // El resultado va de 0 a 999
        // System.out.println("Los milisegundos actuales son: " + fecha.get(Calendar.MILLISECOND));
        // System.out.println();

        // System.out.println("------------------------------");
        // System.out.println("        MODIFICACIONES ");
        // System.out.println("------------------------------");
        // System.out.println();

        // /*
        //  * Calendar permite modificar las fechas con el método set()
        //  * El método set() tiene dentro distintos parámetros que servirán para modificar esas partes de la fecha
        //  * 
        //  * set(Año, Mes, Dia, Hora, Minuto, Segundo)
        //  * 
        //  * No es necesario dar un argumento (valor) a cada uno de los parámetros.
        //  * Set únicamente modificará aquella parte de la fecha cuyo parámetro tenga valor.
        //  */
        // System.out.println("Recordemos la fecha: " + fecha.getTime());
        // // Modificación de fecha:
        // fecha.set(Calendar.YEAR, 2023);
        // System.out.println("Vamos a modificar el año poniéndolo en 2023: " + fecha.getTime());
        // System.out.println();
        
        // // Se pueden hacer varias modificaciones al mismo tiempo. Vamos a cambiar:
        // // Año = 2025
        // // Mes = Abril
        // // Dia = 3
        // // Hora = 2
        // // Minuto = 13
        // // Segundos = 33
        // // Modificación de fecha:
        // fecha.set(2025, Calendar.APRIL, 3, 2, 13, 33);
        // // fecha.set(2025, 3, 3, 2, 13, 33); --> El mes se puede poner en número, recuerda que 0=enero, 3=abril
        // System.out.println("Cambiamos varios valores a la vez: " + fecha.getTime());
        // System.out.println();

        // /*
        //  * ====ADVERTENCIA====
        //  * Modificar las fechas erróneamente no va a hacer saltar un error.
        //  * Si a febrero le asignamos el día 30 saltará al mes siguiente.
        //  * Esto supone un problema porque podemos estar trabajando con fechas incorrectas.
        //  */

        // System.out.println("---------------------------");
        // System.out.println("        OPERACIONES ");
        // System.out.println("---------------------------");
        // System.out.println();

        // /* 
        //  * java.util.Date no permitía operar con fechas, ni añadir ni sustraer días o meses.
        //  * Esto con java.util.Calendar se empezó a poder hacer, pero de manera del todo intuitiva.
        //  * 
        //  * Hay dos métodos para modificar las fechas: add() y roll().
        //  * 
        //  * ---add()---
        //  * Modifica la fecha de tal manera que si rebasa el mes, va a modificar también el mes.
        //  * Por ejemplo, tenemos fecha 31-01-2025 y queremos añadir 1 día. 
        //  * Pasaría a 32-01-2025 que no existe, así que salta a día 01, pero no solo estamos modificando
        //  * día, como ha rebasado la capacidad del mes 01 también modificará el mes pasando a 02.
        //  * La fecha resultante después de añadir 1 día a 31-01-2025 será 01-02-2025.
        //  * 
        //  * ---roll()---
        //  * Únicamente modifica la parte de la fecha deseada sin alterar el resto.
        //  * Por ejemplo, tenemos fecha 03-12-2024 y queremos sumar 1 mes.
        //  * Es el último mes y no existe el mes 13, así que saltará al mes 01.
        //  * roll() no va a modificar ninguna otra parte de la fecha:
        //  * la fecha resultante después de añadir 1 mes con roll() será 03-01-2024.
        //  *
        //  * *** Mientras que add() hubiera cambiado el año, roll() únicamente ha cambiado el mes.
        //  */
        
        // // Reset de la fecha para volver a tener la fecha actual:
        // fecha = Calendar.getInstance();
        // System.out.println("METODO ADD");
        // System.out.println("Añadiendo un día a la fecha actual: " + fecha.getTime());
        // fecha.add(Calendar.DAY_OF_MONTH, 1);
        // System.out.println("Nueva fecha con un día añadido: " + fecha.getTime());
        // System.out.println();
        // System.out.println("Si le añadimos 5 días saltará de mes (fecha tal como está): " +fecha.getTime());
        // fecha.add(Calendar.DAY_OF_MONTH, 15);
        // System.out.println("Fecha modificada: " + fecha.getTime());
        // System.out.println();
        // System.out.println("*********************");
        // System.out.println();
        // System.out.println("METODO ROLL");
        // // Reset de la fecha para volver a tener la fecha actual:
        // fecha = Calendar.getInstance();
        // System.out.println("Añadiendo 6 días a la fecha actual: " + fecha.getTime());
        // fecha.roll(Calendar.DAY_OF_MONTH, 15);
        // System.out.println("Nueva fecha con seis días añadidos: " + fecha.getTime());
        // System.out.println();
        // /*
        //  * Con la suma de días que hemos hecho tendríamos que pasar a abril, pero lo único
        //  * que se modifica es el día.
        //  */


        // /* 
        //  * java.util Calendar --> clase introducida en Java 1.1 (1997).
        //  * La finalidad era mejorar la anterior clase Date.
        //  * Date tenía métodos obsoletos, además que no permitía hacer operaciones.
        //  * Tampoco manejaba correctamente las diferentes zonas horarias.
        //  * Aunque solucionaba parte de esos problemas, seguía siendo poco intuitivo (meses que empiezan en 0...)
        //  * En Java 8+ llega el paquete java.time que introduce diferentes clases
        //  * que permiten trabajar con fechas de una manera mucho más moderna e intuitiva.
        //  */
        
    }
}